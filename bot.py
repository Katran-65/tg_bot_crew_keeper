import logging
import random
from telegram import Update
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes, CallbackContext
import datetime
from typing import Dict, Tuple

# Настройка логирования
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)

BOT_TOKEN = "8217389924:AAGx0JqHebI9y26bPPwSACaOByR9wza8LDk"

# Расширенный словарь ответов
RESPONSES = {
    "Манчестер": ["Манчестер синий", "Если щас опять начнется противостояние МЮ, Челси и Ливерпуля, я уйду спать!",
                  "Надоели"],
    "манчестер": ["Манчестер синий", "Если щас опять начнется противостояние МЮ, Челси и Ливерпуля, я уйду спать!",
                  "Надоели"],
    "Челси": ["Опять о своём футболе базарят", "скуууушноооо", "опяяяяять!"],
    "Душнить": ["Откройте форточку", "Зануда)", "кубок зануд уже твой, забей"],
    "челси": ["Опять о своём футболе базарят", "скуууушноооо"],
    "душнить": ["Откройте форточку", "Зануда)", "кубок зануд уже твой, забей"],
    "душни": ["Откройте форточку", "Зануда)", "кубок зануд уже твой, забей"],
    "душно": ["Откройте форточку", "Зануда)", "кубок зануд уже твой, забей"],
    "душните": ["Откройте форточку", "Зануда)", "кубок зануд уже твой, забей"],
    "Феникс": ["Феникскскскс", "мы командо. футболето проиграто неудачо. Мы играем забиваем умираем. мы фениксо. любим катю лену таню пиццу"],
    "феникс": ["Феникскскскс", "мы командо. футболето проиграто неудачо. Мы играем забиваем умираем. мы фениксо. любим катю лену таню пиццу"],
    "похмелье": ["меньше надо было пить", "а кто в этом виноват?", "кря(", "соболезную"],
    "похмелья": ["меньше надо было пить", "а кто в этом виноват?", "кря(", "соболезную"],
    "анекдот": ["Анекдот? Про нюанс?", "ВНИМАНИЕ АНЕКДОТ", "Однажды гидролог и геолог встретились в пабе..."],
    "анекдоты": ["Анекдот? Про нюанс?", "ВНИМАНИЕ АНЕКДОТ", "Однажды гидролог и геолог встретились в пабе..."],
    "Похмелье": ["меньше надо было пить", "а кто в этом виноват?", "кря(", "соболезную"],
    "Похмелья": ["меньше надо было пить", "а кто в этом виноват?", "кря(", "соболезную"],
    "Анекдот": ["Анекдот? Про нюанс?", "ВНИМАНИЕ АНЕКДОТ", "Однажды гидролог и геолог встретились в пабе..."],
    "Анекдоты": ["Анекдот? Про нюанс?", "ВНИМАНИЕ АНЕКДОТ", "Однажды гидролог и геолог встретились в пабе..."],
    "пиво": ["Пей пиво, ешь мясо", "Щас вообще не удивительно что в чате Бухлоход разговор о пиве", "Когда бухать?"],
    "Пиво": ["Пей пиво, ешь мясо", "Щас вообще не удивительно что в чате Бухлоход разговор о пиве", "Когда бухать?"],
    "пива": ["Пей пиво, ешь мясо", "Щас вообще не удивительно что в чате Бухлоход разговор о пиве", "Когда бухать?"],
    "Пива": ["Пей пиво, ешь мясо", "Щас вообще не удивительно что в чате Бухлоход разговор о пиве", "Когда бухать?"],
    "тролл": ["Все вы тут тролли", "вы когда-нибудь слышали о мумитроллинге?", "шутеечки?"],
    "Тролл": ["Все вы тут тролли", "вы когда-нибудь слышали о мумитроллинге?", "шутеечки?"],
    "Лиза": ["Лиза - мой любимы персонаж в этом чате", "елизавееета жила в краснодареее", "джин?"],
    "лиза": ["Лиза - мой любимы персонаж в этом чате", "елизавееета жила в краснодареее", "джин?"],
    "Лизу": ["Лиза - мой любимы персонаж в этом чате", "елизавееета жила в краснодареее", "джин?"],
    "лизу": ["Лиза - мой любимы персонаж в этом чате", "елизавееета жила в краснодареее", "джин?"],
    "Лизе": ["Лиза - мой любимы персонаж в этом чате", "елизавееета жила в краснодареее", "джин?"],
    "лизе": ["Лиза - мой любимы персонаж в этом чате", "елизавееета жила в краснодареее", "джин?"],
    "Лизы": ["Лиза - мой любимы персонаж в этом чате", "елизавееета жила в краснодареее", "джин?"],
    "лизы": ["Лиза - мой любимы персонаж в этом чате", "елизавееета жила в краснодареее", "джин?"],
    "Katran": ["Обращаться к Екатерине через личного секретаря", "екатерина вне зоны действия сети, отправьте свое сообщение в чате сбербанка", "катран - это акула кстати"],
    "enel": ["Че вам надо от Лены? ацтаньте от человека в токое время", "у аппарата Елена Алексеевна, говорите", "Для получения справочной информации от Enel зайдите в бар"],
    "TatyanaShumilova": ["Татьяна будет на связи через полчаса. А если нет, то перечитайте это сообщение.", "Ищу аналитиков, присылайте резюме", "она на даче..."],
    "Ekaterina_K_": ["в рамке защищает честь фениксо, перезвоните позжеее", "Чуть что сразу Катя, что не спросишь - Катя", "Катя мчит, чтобы ответить на ваш запрос"],
    "Джек": ["Я тут!", "Вы про меня или про виски?", "Че надо?"],
    "джек": ["Я тут!", "Вы про меня или про виски?", "Че надо?"]
}

# База интересных вопросов
QUESTIONS = [
    "Какая книга изменила твою жизнь и почему?",
    "Если бы у тебя был суперсила на один день, что бы ты выбрал и как бы использовал?",
    "Какой самый безумный поступок ты совершил в жизни?",
    "Какой фильм ты можешь пересматривать бесконечно?",
    "Если бы ты мог поужинать с любым человеком из истории, кого бы выбрал и о чем бы спросил?",
    "Какое твое самое странное умение или талант?",
    "Какой самый неловкий момент случился с тобой на свидании?",
    "Если бы ты узнал, что завтра конец света, как бы провел сегодняшний день?",
    "Какая песня заставляет тебя плакать или смеяться без причины?",
    "Какой самый лучший совет тебе давали в жизни?",
    "Если бы ты мог жить в любой вымышленной вселенной, какую бы выбрал?",
    "Какое твое самое детское воспоминание?",
    "Если бы ты мог изменить одну вещь в своем прошлом, что бы это было?",
    "Какой самый необычный сон тебе снился?",
    "Если бы ты стал знаменитым, что бы ты хотел, чтобы о тебе помнили?",
    "Какое блюдо ты считаешь своим кулинарным шедевром?",
    "Если бы животные могли говорить, с каким бы ты хотел поболтать?",
    "Какой самый красивый уголок природы, где ты бывал?",
    "Если бы ты мог мгновенно выучить любой язык, какой бы выбрал?",
    "Какая шутка или анекдот всегда заставляет тебя смеяться?",
    "Если бы ты мог вернуться в любой возраст, какой бы выбрал и почему?",
    "Какой самый ценный жизненный урок ты усвоил?",
    "Если бы ты мог создать новый праздник, каким бы он был?",
    "Какая компьютерная игра затянула тебя больше всего?",
    "Если бы ты мог решить одну мировую проблему, какую бы выбрал?",
    "Какой самый странный предмет в твоей коллекции?",
    "Если бы ты мог быть экспертом в любой области, какой бы выбрал?",
    "Какое твое самое большое иррациональное страдание?",
    "Если бы ты мог получить ответ на любой вопрос, что бы спросил?",
    "Какой самый неожиданный комплимент ты получал?",
    "Если бы ты мог поменяться местами с кем-то на неделю, с кем бы?",
    "Какая самая безумная вещь в твоем списке желаний?",
    "Если бы ты мог создать духи с любым запахом, каким бы он был?",
    "Какой самый смешной случай из твоей школьной жизни?",
    "Если бы ты мог добавить любую эмоцию в палитру человеческих чувств, какую бы создал?",
    "Какое твое самое странное пищевое сочетание, которое ты обожаешь?",
    "Если бы ты мог стать персонажем любого фильма, кем бы стал?",
    "Какой самый нелепый спор у тебя был в жизни?",
    "Если бы ты мог знать абсолютную истину об одной вещи, что бы это было?",
    "Какая самая странная вещь, которая тебя впечатлила?",
    "Если бы ты мог иметь любое животное в качестве питомца, какое бы выбрал?",
    "Какой самый запоминающийся подарок ты получал?",
    "Если бы ты мог изобрети что-то полезное для человечества, что бы это было?",
    "Какая самая смешная опечатка или автоисправление у тебя была?",
    "Если бы ты мог жить в любом десятилетии 20 века, какое бы выбрал?"
]

# База комплиментов
COMPLIMENTS = [
    "Ты сегодня просто сияешь! ✨",
    "У тебя отличное чувство юмора! 😄",
    "С тобой всегда так приятно общаться! 💫",
    "Ты невероятно умён! 🧠",
    "Твоя энергия заразительна! ⚡",
    "У тебя прекрасный вкус! 👌",
    "Ты вдохновляешь окружающих! 🌟",
    "С тобой никогда не скучно! 🎉",
    "Ты мастерски подбираешь слова! 💬",
    "У тебя потрясающая харизма! 🔥",
    "Ты всегда находишь нужные слова! 📝",
    "С тобой приятно иметь дело! 🤝",
    "Ты излучаешь позитив! ☀️",
    "У тебя уникальный взгляд на вещи! 👁️",
    "Ты делаешь мир лучше! 🌍",
    "С тобой можно говорить на любые темы! 💭",
    "Ты всегда поднимаешь настроение! 😊",
    "У тебя золотые руки! 👐",
    "Ты прекрасный собеседник! 🗣️",
    "С тобой хочется делиться идеями! 💡"
]

# База ответов "Да"
YES_RESPONSES = [
    "Абсолютно да! ✅",
    "Безусловно! 👍",
    "Сто процентов! 💯",
    "Не сомневайся! 😉",
    "Естественно! 🌟",
    "Разумеется! 🤓",
    "Без вариантов! 🚀",
    "Определённо да! ✅",
    "Конечно! 😊",
    "Само собой! ⚡",
    "Бесспорно! 🎯",
    "Да, и это не обсуждается! 💪",
    "Ещё бы! 🔥",
    "Без сомнений! 😎",
    "Да, и точка! 🎉",
    "Несомненно! ✨",
    "Да, конечно! 🌈",
    "А как иначе! 💥"
]

# Словарь для хранения счетчиков сообщений по чатам
message_counters: Dict[int, int] = {}
# Словарь для хранения порогов отправки комплиментов по чатам
compliment_thresholds: Dict[int, int] = {}
# Словарь для хранения состояний команды /leave
leave_states: Dict[int, Dict] = {}


def should_send_compliment(chat_id: int) -> bool:
    """Определяет, стоит ли отправлять комплимент в этом чате"""
    # Инициализация счетчика для нового чата
    if chat_id not in message_counters:
        message_counters[chat_id] = 0
        # Случайный порог между 100 и 150 сообщениями
        compliment_thresholds[chat_id] = random.randint(100, 150)
        return False

    # Увеличиваем счетчик сообщений
    message_counters[chat_id] += 1

    # Проверяем, достигли ли порога
    if message_counters[chat_id] >= compliment_thresholds[chat_id]:
        # Сбрасываем счетчик и устанавливаем новый порог
        message_counters[chat_id] = 0
        compliment_thresholds[chat_id] = random.randint(100, 150)
        return True

    return False


async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработчик команды /start"""
    await update.message.reply_text(
        "Привет! Я бот Джек. Создан специально чтобы развлекать экипаж Бухлохода."
        "У меня будет много функций, но пока их чуть-чуть. "
        "Используй /help для списка команд."
    )


async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработчик команды /help"""
    help_text = """
🤖 **Доступные команды:**
/start - Начать работу с ботом
/help - Показать это сообщение
/question - Я задам тебе вопрос и хочу получить честный ответ.
/whattodo - Задай вопрос и узнай мое мнение. (Я отвечу да или нет)
/leave - Начать процедуру выхода из чата

"""
    await update.message.reply_text(help_text)


async def question_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработчик команды /question - задает случайный интересный вопрос"""
    question = random.choice(QUESTIONS)
    await update.message.reply_text(f"🤔 Вопрос для размышления:\n\n{question}")


async def whattodo_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработчик команды /whattodo - всегда отвечает 'Да' в разной форме"""
    response = random.choice(YES_RESPONSES)
    await update.message.reply_text(response)


async def leave_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработчик команды /leave - процедура выхода из чата"""
    chat_id = update.message.chat_id
    user_id = update.message.from_user.id
    user_name = update.message.from_user.first_name
    
    # Инициализация состояния для пользователя
    if chat_id not in leave_states:
        leave_states[chat_id] = {}
    
    leave_states[chat_id][user_id] = {
        "step": 1,
        "user_name": user_name
    }
    
    # Первый вопрос
    await update.message.reply_text(f"{user_name}, ты точно хочешь нас покинуть?")


async def handle_leave_response(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработка ответов на вопросы команды /leave"""
    chat_id = update.message.chat_id
    user_id = update.message.from_user.id
    message_text = update.message.text.lower()
    
    # Проверяем, находится ли пользователь в процессе выхода
    if (chat_id not in leave_states or 
        user_id not in leave_states[chat_id]):
        return
    
    state = leave_states[chat_id][user_id]
    step = state["step"]
    user_name = state["user_name"]
    
    # Проверяем ответы на каждом шаге
    if step == 1:
        if any(word in message_text for word in ["да", "yes", "точно", "хочу", "уверен"]):
            state["step"] = 2
            await update.message.reply_text("Это твое трезвое и взвешенное решение?")
        else:
            # Пользователь передумал на первом шаге
            del leave_states[chat_id][user_id]
            await update.message.reply_text(f"🎉 Ура! {user_name} остается с нами! Мы так рады!")
    
    elif step == 2:
        if any(word in message_text for word in ["да", "yes", "трезвое", "взвешенное", "решение"]):
            state["step"] = 3
            await update.message.reply_text("Прости, ты уверен, что не передумаешь?")
        else:
            # Пользователь передумал на втором шаге
            del leave_states[chat_id][user_id]
            await update.message.reply_text(f"🎉 Отлично! {user_name} передумал(а) уходить! Мы счастливы!")
    
    elif step == 3:
        if any(word in message_text for word in ["да", "yes", "уверен", "точно", "не передумаю"]):
            # Пользователь подтвердил выход
            del leave_states[chat_id][user_id]
            await update.message.reply_text(f"😔 Очень жаль, что {user_name} покидает нас... Мы будем скучать!")
            
            # Пытаемся кикнуть пользователя (если у бота есть права)
            try:
                await context.bot.ban_chat_member(chat_id, user_id)
                # Разбаниваем сразу, чтобы пользователь мог вернуться по ссылке
                await context.bot.unban_chat_member(chat_id, user_id)
            except Exception as e:
                logging.warning(f"Не удалось кикнуть пользователя: {e}")
                
            # Создаем ссылку для приглашения
            try:
                invite_link = await context.bot.create_chat_invite_link(
                    chat_id, 
                    member_limit=1,
                    creates_join_request=False
                )
                invite_url = invite_link.invite_link
                
                # Отправляем ссылку в чат
                await update.message.reply_text(
                    f"Если {user_name} передумает, вот ссылка для возвращения:\n{invite_url}"
                )
                
                # Пытаемся отправить ссылку пользователю в личку
                try:
                    await context.bot.send_message(
                        user_id,
                        f"Если ты передумаешь, вот ссылка для возвращения в чат:\n{invite_url}\n\nМы будем ждать тебя! ❤️"
                    )
                except Exception as e:
                    logging.warning(f"Не удалось отправить сообщение пользователю: {e}")
                    
            except Exception as e:
                logging.warning(f"Не удалось создать ссылку приглашения: {e}")
                
        else:
            # Пользователь передумал на третьем шаге
            del leave_states[chat_id][user_id]
            await update.message.reply_text(f"🎉 Фух! {user_name} остается! Мы так рады, что ты с нами!")


async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработка входящих сообщений"""
    message_text = update.message.text.lower()
    chat_id = update.message.chat_id
    user_name = update.message.from_user.first_name

    # Сначала проверяем, не является ли сообщение ответом на команду /leave
    if await handle_leave_response(update, context):
        return

    # 1. Случайный комплимент (раз в 100-150 сообщений)
    if should_send_compliment(chat_id):
        compliment = random.choice(COMPLIMENTS)
        await update.message.reply_text(f"{user_name}, {compliment}")
        return

    # 2. Реакция на триггерные слова с вероятностью 40%
    triggered_responses = []
    for trigger, responses in RESPONSES.items():
        if trigger in message_text:
            triggered_responses.extend(responses)

    # Если нашли совпадения, отправляем случайный ответ с вероятностью 40%
    if triggered_responses and random.random() < 0.4:
        response = random.choice(triggered_responses)
        await update.message.reply_text(response)


async def handle_user_left(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработка события, когда пользователь покидает чат"""
    if update.message.left_chat_member:
        user = update.message.left_chat_member
        chat_id = update.message.chat_id
        
        # Создаем ссылку для приглашения
        try:
            invite_link = await context.bot.create_chat_invite_link(
                chat_id, 
                member_limit=1,
                creates_join_request=False
            )
            invite_url = invite_link.invite_link
            
            # Отправляем сообщение в чат
            await update.message.reply_text(
                f"😕 Кто-то из мелких опять нажимает на кнопки в телегафоне...\n\n"
                f"Если {user.first_name} хочет вернуться, отправьте ему эту ссылку:\n{invite_url}"
            )
            
            # Пытаемся отправить ссылку ушедшему пользователю
            try:
                await context.bot.send_message(
                    user.id,
                    f"👋 Привет! Вижу, ты покинул(а) наш чат. Если это была случайность, "
                    f"вот ссылка для возвращения:\n{invite_url}\n\nМы будем рады видеть тебя снова! ❤️"
                )
            except Exception as e:
                logging.warning(f"Не удалось отправить сообщение ушедшему пользователю: {e}")
                
        except Exception as e:
            logging.warning(f"Не удалось создать ссылку приглашения: {e}")
            await update.message.reply_text(
                f"😕 {user.first_name} покинул(а) чат. Кто-то опять нажимает на кнопки в телефоне..."
            )


async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработка ошибок"""
    logging.error(f"Ошибка: {context.error}")


def main():
    """Основная функция"""
    application = Application.builder().token(BOT_TOKEN).build()

    # Добавляем обработчики команд
    application.add_handler(CommandHandler("start", start_command))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("question", question_command))
    application.add_handler(CommandHandler("whattodo", whattodo_command))
    application.add_handler(CommandHandler("leave", leave_command))

    # Добавляем обработчик сообщений (сначала проверяем на ответы для /leave)
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    
    # Добавляем обработчик выхода пользователей из чата
    application.add_handler(MessageHandler(filters.StatusUpdate.LEFT_CHAT_MEMBER, handle_user_left))

    # Добавляем обработчик ошибок
    application.add_error_handler(error_handler)

    print("🤖 Бот запущен и готов к работе!")
    application.run_polling()


if __name__ == "__main__":
    main()

